'use strict';
var tokenizer_1 = require('./tokenizer');
exports.tokenizer = tokenizer_1.default;
function makeMixinParameters(text, offset) {
    var variables = [];
    if (!text || text === '()') {
        return variables;
    }
    text = text.slice(1, text.length - 1);
    var params = text.split(/([,;]\s*)(?=\$)/);
    offset += 1;
    for (var i = 0; i < params.length; i = i + 2) {
        var token = params[i];
        var stat = token.match(/([\n\t\r\s]*)(\$[\w-]+)(?:\s*:\s*(.*))?/);
        offset += stat[1].length || 0;
        variables.push({
            name: stat[2],
            value: stat[3] ? stat[3].trim() : null,
            offset: offset
        });
        offset += token.trim().length + (params[i + 1] ? params[i + 1].length : 0);
    }
    return variables;
}
function parseSymbols(text) {
    var tokens = tokenizer_1.default(text);
    var variables = [];
    var mixins = [];
    var functions = [];
    var imports = [];
    var token;
    var pos = 0;
    var offset = 0;
    var length = tokens.length;
    while (pos < length) {
        token = tokens[pos];
        if (token[0] === 'at-word' && token[1] === '@import') {
            pos++;
            var str = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === ';') {
                    break;
                }
                str += token[1];
                pos++;
            }
            str.split(/,\s*/).forEach(function (x) {
                var stat = x.match(/['"](.*)['"]/);
                if (!stat) {
                    return;
                }
                imports.push({
                    filepath: stat[1],
                    dynamic: /[#{}\*]/.test(stat[1]),
                    css: /\.css$/.test(stat[1])
                });
            });
        }
        else if (token[0] === 'at-word') {
            if (token[1] !== '@mixin' && token[1] !== '@function') {
                pos++;
                while (pos < length) {
                    token = tokens[pos];
                    if (token[0] === '{') {
                        break;
                    }
                    else if (token[0] === ')' && tokens[pos + 1] && tokens[pos + 1] === ';') {
                        pos++;
                        break;
                    }
                    pos++;
                }
                continue;
            }
            var entity = token[1] === '@mixin' ? mixins : functions;
            offset = token[2];
            pos++;
            var name_1 = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === 'brackets' || token[0] === '(' || token[0] === '{') {
                    break;
                }
                name_1 += token[1];
                pos++;
            }
            var paramsOffset = offset;
            var params = '';
            if (token[0] === 'brackets') {
                paramsOffset = token[2];
                params = token[1];
            }
            else if (token[0] === '(') {
                paramsOffset = token[2];
                pos++;
                while (pos < length) {
                    token = tokens[pos];
                    if (token[0] === ')') {
                        break;
                    }
                    params += token[1];
                    pos++;
                }
                params = "(" + params + ")";
            }
            while (token[0] === '{' && pos < length) {
                token = tokens[pos];
                pos++;
            }
            if (name_1) {
                entity.push({
                    name: name_1.trim(),
                    parameters: makeMixinParameters(params, paramsOffset),
                    offset: offset
                });
            }
            else {
                pos--;
            }
        }
        else if (token[0] === 'word' && token[1].startsWith('$')) {
            offset = token[2];
            pos++;
            var name_2 = token[1];
            var value = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === ';') {
                    break;
                }
                else if (token[0] === 'word' || token[0] === 'at-word' || token[0] === 'string' || token[0] === 'space' || token[0] === 'brackets') {
                    value += token[1];
                }
                pos++;
            }
            if (pos === length && token[0] !== ';') {
                continue;
            }
            variables.push({
                name: name_2,
                value: value.trim(),
                offset: offset
            });
        }
        else if (token[0] === '{') {
            var ruleset = 1;
            pos++;
            while (pos < length) {
                token = tokens[pos];
                if (ruleset === 0) {
                    break;
                }
                else if (token[0] === '{') {
                    ruleset++;
                }
                else if (token[0] === '}') {
                    ruleset--;
                }
                pos++;
            }
        }
        pos++;
    }
    return {
        variables: variables,
        mixins: mixins,
        functions: functions,
        imports: imports
    };
}
exports.parseSymbols = parseSymbols;
